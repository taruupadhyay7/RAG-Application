OPERATING SYSTEM

Lecture Notes

Lecture

What is an Operating System?
 A program that acts as an intermediary between a user of a computer and the computer hardware.
 An operating System is a collection of system programs that together control the operations of a computer
system.
Some examples of operating systems are UNIX, Mach, MS-DOS, MS-Windows, Windows/NT, Chicago, OS/2,
MacOS, VMS, MVS, and VM.
Operating system goals:
 Execute user programs and make solving user problems easier.
 Make the computer system convenient to use.
 Use the computer hardware in an efficient manner.
Computer System Components
Hardware – provides basic computing resources (CPU, memory, I/O devices).
Operating system – controls and coordinates the use of the hardware among the various application
programs for the various users.
Applications programs – Define the ways in which the system resources are used to solve the computing
problems of the users (compilers, database systems, video games, business programs).
Users (people, machines, other computers).
Abstract View of System Components

Operating System Definitions
Resource allocator – manages and allocates resources.
Control program – controls the execution of user programs and operations of I/O devices .
Kernel – The one program running at all times (all else being application programs).
Components of OS: OS has two parts. (1)Kernel.(2)Shell.
(1) Kernel is an active part of an OS i.e., it is the part of OS running at all times. It is a programs which
can interact with the hardware. Ex: Device driver, dll files, system files etc.
(2) Shell is called as the command interpreter. It is a set of programs used to interact with the application
programs. It is responsible for execution of instructions given to OS (called commands).
Operating systems can be explored from two viewpoints: the user and the system.
User View: From the user’s point view, the OS is designed for one user to monopolize its resources, to
maximize the work that the user is performing and for ease of use.
System View: From the computer's point of view, an operating system is a control program that manages the
execution of user programs to prevent errors and improper use of the computer. It is concerned with the
operation and control of I/O devices.

Lecture

Functions of Operating System:
Process Management
A process is a program in execution. A process needs certain resources, including CPU time, memory,
files, and I/O devices, to accomplish its task.
The operating system is responsible for the following activities in connection with process management.
✦ Process creation and deletion.
✦ process suspension and resumption.
✦ Provision of mechanisms for:
 process synchronization
 process communication
Main-Memory Management
Memory is a large array of words or bytes, each with its own address. It is a repository of quickly
accessible data shared by the CPU and I/O devices.
Main memory is a volatile storage device. It loses its contents in the case of system failure.
The operating system is responsible for the following activities in connections with memory management:
 Keep track of which parts of memory are currently being used and by whom.
 Decide which processes to load when memory space becomes available.
 Allocate and de-allocate memory space as needed.
File Management
A file is a collection of related information defined by its creator. Commonly, files represent programs
(both source and object forms) and data.
The operating system is responsible for the following activities in connections with file management:
✦ File creation and deletion.
✦ Directory creation and deletion.
✦ Support of primitives for manipulating files and directories.
✦ Mapping files onto secondary storage.
✦ File backup on stable (nonvolatile) storage media.
I/O System Management
The I/O system consists of:
✦ A buffer-caching system
✦ A general device-driver interface
✦ Drivers for specific hardware devices
Secondary-Storage Management
Since main memory (primary storage) is volatile and too small to accommodate all data and programs
permanently, the computer system must provide secondary storage to back up main memory.
Most modern computer systems use disks as the principle on-line storage medium, for both programs and data.
The operating system is responsible for the following activities in connection with disk management:
✦ Free space management
✦ Storage allocation
✦ Disk scheduling
Networking (Distributed Systems)
 A distributed system is a collection processors that do not share memory or a clock. Each processor has
its own local memory.
 The processors in the system are connected through a communication network.
 Communication takes place using a protocol.
 A distributed system provides user access to various system resources.
 Access to a shared resource allows:
✦ Computation speed-up

Lecture
Evolution of OS:
Mainframe Systems
Reduce setup time by batching similar jobs Automatic job sequencing – automatically transfers control from one
job to another. First rudimentary
operating system. Resident monitor
 initial control in monitor
 control transfers to job
 when job completes control transfers pack to monitor
Batch Processing Operating System:
 This type of OS accepts more than one jobs and these jobs are batched/ grouped together according to their
similar requirements. This is done by computer operator. Whenever the computer becomes available, the
batched jobs are sent for execution and gradually the output is sent back to the user.
 It allowed only one program at a time.
 This OS is responsible for scheduling the jobs according to priority and the resource required.
Multiprogramming Operating System:
 This type of OS is used to execute more than one jobs simultaneously by a single processor. it increases CPU
utilization by organizing jobs so that the CPU always has one job to execute.
 The concept of multiprogramming is described as follows:
 All the jobs that enter the system are stored in the job pool( in disc). The operating system loads a set
of jobs from job pool into main memory and begins to execute.
 During execution, the job may have to wait for some task, such as an I/O operation, to complete. In
a multiprogramming system, the operating system simply switches to another job and executes.
When that job needs to wait, the CPU is switched to another job, and so on.
 When the first job finishes waiting and it gets the CPU back.
 As long as at least one job needs to execute, the CPU is never idle.
Multiprogramming operating systems use the mechanism of job scheduling and CPU scheduling.
Time-Sharing/multitasking Operating Systems
Time sharing (or multitasking) OS is a logical extension of multiprogramming. It provides extra facilities such as:
 Faster switching between multiple jobs to make processing faster.
 Allows multiple users to share computer system simultaneously.
 The users can interact with each job while it is running.
These systems use a concept of virtual memory for effective utilization of memory space. Hence, in this OS, no
jobs are discarded. Each one is executed using virtual memory concept. It uses CPU scheduling, memory
management, disc management and security management. Examples: CTSS, MULTICS, CAL, UNIX etc.
Multiprocessor Operating Systems
Multiprocessor operating systems are also known as parallel OS or tightly coupled OS. Such operating
systems have more than one processor in close communication that sharing the computer bus, the clock and
sometimes memory and peripheral devices. It executes multiple jobs at same time and makes the processing
faster.
Multiprocessor systems have three main advantages:
 Increased throughput: By increasing the number of processors, the system performs more work in less time.
The speed-up ratio with N processors is less than N.
 Economy of scale: Multiprocessor systems can save more money than multiple single-processor systems,
because they can share peripherals, mass storage, and power supplies.
 Increased reliability: If one processor fails to done its task, then each of the remaining processors must pick
up a share of the work of the failed processor. The failure of one processor will not halt the system, only
slow it down.
The ability to continue providing service proportional to the level of surviving hardware is called graceful
degradation. Systems designed for graceful degradation are called fault tolerant.

The multiprocessor operating systems are classified into two categories:
Symmetric multiprocessing system
Asymmetric multiprocessing system
 In symmetric multiprocessing system, each processor runs an identical copy of the operating system, and
these copies communicate with one another as needed.
 In asymmetric multiprocessing system, a processor is called master processor that controls other processors
called slave processor. Thus, it establishes master-slave relationship. The master processor schedules the jobs
and manages the memory for entire system.
Distributed Operating Systems
 In distributed system, the different machines are connected in a network and each machine has its own
processor and own local memory.
 In this system, the operating systems on all the machines work together to manage the collective network
resource.
 It can be classified into two categories:
Client-Server systems
Peer-to-Peer systems
Advantages of distributed systems.
 Resources Sharing
 Computation speed up – load sharing
 Reliability
 Communications
 Requires networking infrastructure.
 Local area networks (LAN) or Wide area networks (WAN)
.
Desktop Systems/Personal Computer Systems
 The PC operating system is designed for maximizing user convenience and responsiveness. This system is
neither multi-user nor multitasking.
 These systems include PCs running Microsoft Windows and the Apple Macintosh. The MS-DOS operating
system from Microsoft has been superseded by multiple flavors of Microsoft Windows and IBM has
upgraded MS-DOS to the OS/2 multitasking system.
 The Apple Macintosh operating system has been ported to more advanced hardware, and now includes new
features such as virtual memory and multitasking.
Real-Time Operating Systems (RTOS)
 A real-time operating system (RTOS) is a multitasking operating system intended for applications with fixed
deadlines (real-time computing). Such applications include some small embedded systems, automobile
engine controllers, industrial robots, spacecraft, industrial control, and some large-scale computing systems.
 The real time operating system can be classified into two categories:
hard real time system and 2. soft real time system.
 A hard real-time system guarantees that critical tasks be completed on time. This goal requires that all
delays in the system be bounded, from the retrieval of stored data to the time that it takes the operating
system to finish any request made of it. Such time constraints dictate the facilities that are available in hard real-
time systems.
 A soft real-time system is a less restrictive type of real-time system. Here, a critical real-time task gets
priority over other tasks and retains that priority until it completes. Soft real time system can be mixed with
other types of systems. Due to less restriction, they are risky to use for industrial control and robotics.

Lecture

Operating System Services
Following are the five services provided by operating systems to the convenience of the users.
Program Execution
The purpose of computer systems is to allow the user to execute programs. So the operating system
provides an environment where the user can conveniently run programs. Running a program involves the
allocating and deallocating memory, CPU scheduling in case of multiprocessing.
I/O Operations
Each program requires an input and produces output. This involves the use of I/O. So the operating
systems are providing I/O makes it convenient for the users to run programs.
File System Manipulation
The output of a program may need to be written into new files or input taken from some files. The
operating system provides this service.
Communications
The processes need to communicate with each other to exchange information during execution. It may
be between processes running on the same computer or running on the different computers. Communications
can be occur in two ways: (i) shared memory or (ii) message passing
Error Detection
An error is one part of the system may cause malfunctioning of the complete system. To avoid such a
situation operating system constantly monitors the system for detecting the errors. This relieves the user of the
worry of errors propagating to various part of the system and causing malfunctioning.
Following are the three services provided by operating systems for ensuring the efficient operation of
the system itself.
Resource allocation
When multiple users are logged on the system or multiple jobs are running at the same time, resources
must be allocated to each of them. Many different types of resources are managed by the operating system.
Accounting
The operating systems keep track of which users use how many and which kinds of computer resources.
This record keeping may be used for accounting (so that users can be billed) or simply for accumulating usage
statistics.
Protection
When several disjointed processes execute concurrently, it should not be possible for one process to
interfere with the others, or with the operating system itself. Protection involves ensuring that all access to
system resources is controlled. Security of the system from outsiders is also important. Such security starts with
each user having to authenticate him to the system, usually by means of a password, to be allowed access to the
resources.
System Call:
 System calls provide an interface between the process and the operating system.
 System calls allow user-level processes to request some services from the operating system which process
itself is not allowed to do.
 For example, for I/O a process involves a system call telling the operating system to read or write particular
area and this request is satisfied by the operating system.

The following different types of system calls provided by an operating system:

 create process, terminate process
 get process attributes, set process attributes
Process control
 wait for time
 end, abort
 wait event, signal event
 load, execute
 allocate and free memory